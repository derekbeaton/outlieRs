% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rpca_find.outliers.R
\name{rpca_find.outliers}
\alias{rpca_find.outliers}
\title{Find outliers with the Candes Robust PCA approach}
\usage{
rpca_find.outliers(X, center = F, scale = F, quantile.thresh = 0.9,
  S.tolerance = .Machine$double.eps * 100,
  default.lambda = 1/sqrt(max(dim(X))),
  lambda.vec = (1/sqrt(min(dim((X)))/seq(1, 10, 1))),
  sparsity.threshold = 0.05, corrupted.tolerance = 0)
}
\arguments{
\item{X}{Data matrix}

\item{center}{a boolean, vector, or string. See ?expo.scale for details.}

\item{scale}{a boolean, vector, or string. See ?expo.scale for details.}

\item{quantile.thresh}{numeric.}

\item{S.tolerance}{numeric. A tolerance value to threshold extremely small numbers in the S(parse) matrix returned by rpca()}

\item{default.lambda}{numeric. The default lambda value for rpca, which is used for the thresholding procedure}

\item{lambda.vec}{vector (of numerics). A sequence of lambda values used during the sparsity.threshold search; if sparsity.threshold is not met, rpca sparsity search will stop after it goes through all of these values.}

\item{sparsity.threshold}{numeric. A threshold of how sparse the S(parse) matrix should be. lambda.vec is used to perform this search and when sparsity is satisified from that vector, rpca returns its results.}

\item{corrupted.tolerance}{numeric. A tolerance factor to adjust for \code{sparsity.threshold} to allow for 'close enough' +/- tolerance.}
}
\value{
list with many 4 items:

         \item{outliers}{ a matrix with 4 columns.
             The first column is 1 (yes) or 0 (no) based on the quantile (based on \code{quantile.thresh}) cutoff based on the proportion of the orthogonal distances: \code{orthogonal.dist(X,S) / orthogonal.dist(L,S)} based on the 'default' RPCA (which uses \code{default.lambda})
             The second column is 1 (yes) or 0 (no) based on the quantile (based on \code{quantile.thresh}) cutoff based on the proportion of the orthogonal distances: \code{orthogonal.dist(X,S) / orthogonal.dist(L,S)} based on the S(parse) and L(ow rank) matrices discovered in the search process (via \code{lambda.vec} and \code{sparsity.threshold})
             The third column is 1 (yes) or 0 (no) based on whether the default RPCA found any data corruptions for that row
             The fourth column is 1 (yes) or 0 (no) based on whether the sparsity search RPCA found any data corruptions for that row
             }
         \item{def.corrupted.threshold}{from the default RPCA a thresholded matrix of only the corrupted rows that also indicates which columns were corrupted}

         \item{corrupted.threshold}{from the sparsity search a thresholded matrix of only the corrupted rows that also indicates which columns were corrupted}

         \item{dists}{a list of the orthogonal distances used to compute outlier estimates in $outliers:
             X.from.S_def_OtoT_orth.dist -- \code{orthogonal.distance(X,S)} from default RPCA
             L_def.from.S_def_OtoT_orth.dist -- \code{orthogonal.distance(L,S)} from default RPCA
             X.from.S_sparse_OtoT_orth.dist -- \code{orthogonal.distance(X,S)} from sparsity search RPCA
             L_sparse.from.S_sparse_OtoT_orth.dist -- \code{orthogonal.distance(L,S)} from sparsity search RPCA
             }
}
\description{
Find outliers with the Candes Robust PCA approach
}
\examples{
data(beer.tasting.notes)
the.data <- expo.scale(beer.tasting.notes$data)
the.data_corrected_for_ABV <- apply(the.data,2, function(x){ resid(lm(x~beer.tasting.notes$sup.data[,"ABV"])) } )
beer_rpca <- rpca_find.outliers(the.data)
beer.corrected_rpca <- rpca_find.outliers(the.data_corrected_for_ABV)
}

